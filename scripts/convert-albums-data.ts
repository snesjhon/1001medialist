/**
 * Convert CSV album data to TypeScript format with iTunes API metadata
 * Usage: npx tsx scripts/convert-albums-data.ts [start] [end]
 * Example: npx tsx scripts/convert-albums-data.ts 0 10
 */

import * as fs from "fs";
import * as path from "path";

interface CSVAlbum {
  year: number;
  album: string;
  artist: string;
}

interface AlbumSeed {
  title: string;
  artist: string;
  year: number;
  list_number: number;
  genre?: string;
  cover_url?: string;
}

interface iTunesResult {
  artistName: string;
  collectionName: string;
  artworkUrl100: string;
  primaryGenreName: string;
  releaseDate: string;
}

interface iTunesResponse {
  resultCount: number;
  results: iTunesResult[];
}

// Read CSV file from Desktop
const CSV_PATH = path.join(process.env.HOME || "", "Desktop", "1001-albums-you-must-hear-before-you-die.csv");

async function fetchItunesMetadata(artist: string, album: string): Promise<Partial<AlbumSeed>> {
  const searchTerm = `${artist} ${album}`.replace(/_/g, " ");
  const url = `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=album&limit=1`;

  try {
    console.log(`Fetching: ${artist} - ${album}`);
    const response = await fetch(url);
    const data = await response.json() as iTunesResponse;

    if (data.resultCount > 0) {
      const result = data.results[0];
      return {
        cover_url: result.artworkUrl100.replace("100x100", "600x600"), // Get higher res artwork
        genre: result.primaryGenreName,
      };
    }

    console.warn(`No iTunes results for: ${artist} - ${album}`);
    return {};
  } catch (error) {
    console.error(`Error fetching iTunes data for ${artist} - ${album}:`, error);
    return {};
  }
}

async function convertAlbums(startIndex: number = 0, endIndex: number = 10) {
  // Read and parse CSV
  const csvContent = fs.readFileSync(CSV_PATH, "utf-8");
  const lines = csvContent.split("\n").filter(line => line.trim());

  // Skip header and get the slice we want
  const dataLines = lines.slice(1);
  const selectedLines = dataLines.slice(startIndex, endIndex);

  const csvAlbums: CSVAlbum[] = selectedLines.map(line => {
    const [year, album, artist] = line.split("|");
    return {
      year: parseInt(year),
      album: album.replace(/_/g, "'"), // Replace underscores with apostrophes
      artist: artist.replace(/_/g, "'"),
    };
  });

  console.log(`\nConverting albums ${startIndex + 1} to ${endIndex}...\n`);

  const enrichedAlbums: AlbumSeed[] = [];

  for (let i = 0; i < csvAlbums.length; i++) {
    const csvAlbum = csvAlbums[i];
    const metadata = await fetchItunesMetadata(csvAlbum.artist, csvAlbum.album);

    enrichedAlbums.push({
      title: csvAlbum.album,
      artist: csvAlbum.artist,
      year: csvAlbum.year,
      list_number: startIndex + i + 1,
      genre: metadata.genre,
      cover_url: metadata.cover_url,
    });

    // Rate limit: wait 200ms between requests
    await new Promise(resolve => setTimeout(resolve, 200));
  }

  // Generate TypeScript file
  const outputPath = path.join(__dirname, "seed-data", "albums-list.ts");

  const fileContent = `/**
 * Source: "1001 Albums You Must Hear Before You Die"
 * Data from: CSV file
 * Metadata from: iTunes Search API
 *
 * This file is auto-generated by scripts/convert-albums-data.ts
 */

export interface AlbumSeed {
  title: string;
  artist: string;
  year: number;
  list_number: number;
  genre?: string;
  cover_url?: string;
}

export const albumsList: AlbumSeed[] = [
${enrichedAlbums.map(album => `  { title: ${JSON.stringify(album.title)}, artist: ${JSON.stringify(album.artist)}, year: ${album.year}, list_number: ${album.list_number}${album.genre ? `, genre: ${JSON.stringify(album.genre)}` : ""}${album.cover_url ? `, cover_url: ${JSON.stringify(album.cover_url)}` : ""} }`).join(",\n")}
];
`;

  fs.writeFileSync(outputPath, fileContent);

  console.log(`\nâœ… Generated ${enrichedAlbums.length} albums to ${outputPath}`);
  console.log(`\nAlbums ${startIndex + 1}-${endIndex} complete!`);
}

// Get command line arguments
const startIndex = parseInt(process.argv[2] || "0");
const endIndex = parseInt(process.argv[3] || "10");

convertAlbums(startIndex, endIndex).catch(console.error);
